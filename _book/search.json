[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Big Book of MLOps",
    "section": "",
    "text": "Preface\nMy journey into MLOps started in late 2023 when I needed to deploy an R Shiny app at the company I was working for. Up to that point there had been no easy way to do this, but luckily for me the MLOps team had put together a Helm chart for deploying containerised applications. I wasn’t part of the data science team, but MLOps very kindly helped me get my app deployed. At the time I had no idea what Kubernetes was or how Helm charts worked - I just containerised my app with Docker, filled in some YAML files, and there it was. I was given access to this mystical platform called ‘ArgoCD’ where I could look at little tiles that represented things I didn’t understand. The only thing I knew for certain was that the little green heart was good, and the broken red heart was bad.\nAround 6 months later I was given the chance to transition over to the MLOps team. I jumped at the chance and never regretted my decision, but I quickly found the learning curve to be steep (somewhere around 89 degrees?) and was overwhelmed with where to begin. A few months into the job I started a google doc - I called it “the big book of MLOPs” (O’Reilly got there first). This was my place to write down notes from the tutorials/courses/books etc. that I was using to gain the knowledge I needed for my job. I decided these notes should sit in a more public forum because a) they could help someone else and b) if my notes could be improved, someone can open a PR and improve them, and c) the human brain can only hold so much information - writing things down is much more effective than trying to remember everything.\nI hope you might find these notes useful, especially if you’re just starting out in MLOps or looking to move into the field.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "This is a book created from markdown and executable code.\nSee @knuth84 for additional discussion of literate programming.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "2  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Summary</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Knuth, Donald E. 1984. “Literate Programming.” Comput.\nJ. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97.",
    "crumbs": [
      "References"
    ]
  },
  {
    "objectID": "kubernetes-networking.html",
    "href": "kubernetes-networking.html",
    "title": "1  Networking in Kubernetes",
    "section": "",
    "text": "1.1 Networking basics",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Networking in Kubernetes</span>"
    ]
  },
  {
    "objectID": "kubernetes-networking.html#networking-basics",
    "href": "kubernetes-networking.html#networking-basics",
    "title": "1  Networking in Kubernetes",
    "section": "",
    "text": "1.1.1 How can computers talk to each other on a network?\n\nIn a simple network, two computers (let’s call them A and B) can exchange information over a network\nThis communication is transmitted via a network switch, a piece of equipment that can connect IT devies\nA computer sends information to the switch via an interface. This interface can be a piece of hardware or software depending on the situation, but is essentially a point of connection between the device and the network\nOn linux, running ip link will print a list of interfaces in the terminal\nIf we assume the network has an ip address of 192.165.1.0, we could add ip addresses to A and B with ip addr add, e.g. ip addr add 192.165.1.10/24 dev eth0 for A and ip addr add 192.165.1.11/24 dev eth0. Note: Here, dev stands for device and eth0 is the first ethernet interface on the system.\nThis would mean that A and B can now exchange packets with each other. Packets are small segments of a larger piece of information being sent over the network, which are recombined by the device that receives them.\n\n\n\n1.1.2 Routing\n\nA router helps connect different networks\nThe router is visible to each network with a different ip address\nNetworks are configured with gateways which connects two different networks\nThe route command in Linux will print the routing table\nRoutes can be added using ip route add\nLet’s assume this network setup:\n\nA and B exist on network 192.165.1.0 - we’ll call this network 1\nC and D exist on network 192.165.2.0 - we’ll call this network 2\nA router is connected to network 1 via the ip 192.165.1.1, and connected to network 2 via the ip 192.165.2.1\n\nWe can connect device A to network 2 by running ip route add 192.165.2.0/24 via 192.165.1.1\nRunning route shows that the router is now a gateway to network 2\nYou can set default routes instead of adding an entry for every single network - ip route add default via 192.165.1.1 - default is sometimes seen as ‘0.0.0.0’\nLinux servers can act as hosts themselves but packet forwarding between interfaces needs to be enabled. This can be a security threat if one interface connects to a public network and the other to a private network.\n\n\n\n1.1.3 Domain Name Systems (DNS)\n\nIn a small simple network (let’s use A and B again, connected via a switch), we can give names to each device. I can add an entry in the /etc/hosts file of A:\n\n192.165.1.11    myname\n\nI can now run ping myname to check connectivity to computer B. However, A will not actually check that B’s host name is myname. And this tasks would quickly become impossible as the network grew\nAn internal DNS server solves the problem - it is a server containing a single source of truth\nIf we assume the DNS server’s ip address is 192.165.1.100, an entry in A’s /etc/resolv.conf file tells it where to resolve domain names:\n\nnameserver  192.165.1.100",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Networking in Kubernetes</span>"
    ]
  },
  {
    "objectID": "kubernetes-networking.html#resources",
    "href": "kubernetes-networking.html#resources",
    "title": "1  Networking in Kubernetes",
    "section": "1.2 Resources",
    "text": "1.2 Resources\nThe resources I used in this chapter include:\n\nCertified Kubernetes Administrator (CKA) with Practice Tests\nWhat is a network switch? by Juniper Networks\nWhat is computer networking? by AWS\nWhat is a network gateway? by NordLayer",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Networking in Kubernetes</span>"
    ]
  }
]